# HWSynQuiz2020
<i>เข้าใจว่าหลาย ๆ คนน่าจะหัวร้อนกับควิซ HW Syn Lab ที่ผ่านมา, กำลังสาปแช่งคนออกข้อสอบ, หรือไล่ให้เก็บข้อสอบไว้ไปสอบกับ...เอ่อ...คนเดียวเถอะ ก็ตาม แต่เราก็เชื่อว่ามีคนจำนวนหนึ่งที่อยากรู้ว่า โจทย์สี่ข้อที่ไม่เหมือนกันเลยเนี่ย ให้เวลาแค่ 40 นาที จะไปทำทันได้ยังไง เดี๋ยวมาลองดูคอนเซปต์คร่าว ๆ ของแต่ละข้อกันครับ ว่ามีวิธีคิด หรือจุดที่จะบัคได้อย่างไรบ้าง</i>

## ภาพรวม
โจทย์ทุกข้อ จะยากขึ้นจาก Lab 2 (แสดงตัวเลข 4 ตัวพร้อมกันบนจอ โดยอาศัยการทำ Clock Division 18 รอบจาก Clock หลักของ BASYS3 ที่เร็ว 100MHz) ขึ้นมาเล็กน้อย คือจะต้องใช้ `always` Block อย่างน้อย 2 Blocks ขึ้นไป ซึ่งปกติ เราจะทำประมาณนี้
```
wire [18:0]clkDiv;
assign clkDiv[0] = clk; // clk คือ Clock ที่ต่อจาก Board
genvar i;
for(i = 1; i <= 18; i = i + 1)
  clockDivider(clkDiv[i-1], clkDiv[i]);
assign targetClk = clkDiv[18];
```
แล้วเอา `targetClk` ไปใช้ แต่ว่าในข้อสอบ ส่วนใดก็ตามที่มีการหน่วงเวลา โจทย์จะบอกในวงเล็บว่า "ช้ากว่า Clock ของ Board อยู่ <img src="https://render.githubusercontent.com/render/math?math=2^n"> เท่า" ซึ่งหมายถึงว่า Clock ต้องถูกแบ่งทั้งหมด n-1 ครั้ง (`clkDiv[0]` มีความถี่ 100MHz, `clkDiv[1]` มีความถี่ 50MHz, ...) ซึ่งนั่นหมายความว่า เราต้องขยาย `wire` `clkDiv` เพิ่มเติม และปรับลูป `genvar` ให้ทำงานเพิ่มขึ้นจนถึงช่องที่ n-1
ซึ่งจุดที่มักจะผิดได้จากการมี `always` Block มากกว่า 1 Block คือ การที่เรากำหนดค่าให้ reg ตัวเดียวกันใน 2 Blocks ในที่นี้ขอยกตัวอย่างของ `ledState` เช่น
```
always @(posedge sevenSegClk)
  ledState = (ledState + 1)%4;
always @(posedge btnClk)
begin
  if(btnC) ledState = 0;
end
```
แบบนี้ จะทำให้เกิด Error ขึ้นช่วง Run Design เนื่องจากหาก `sevenSegClk` และ `btnClk` มี Positive Edge ทั้งคู่ Verilog ก็จะไม่เข้าใจว่าสรุปแล้ว `ledState` ต้องมีค่าเป็นอะไรกันแน่ (อย่าลืม อย่ามองว่า Verilog เป็นภาษา Description Language ไม่ใช่ Imperative แบบ C)
เข้าใจว่าหลาย ๆ คนอาจจะได้ลองทำแล้วใน Lab 3 (Debouncing) แต่หลาย ๆ คนก็ยังไม่เคยทำ สุดท้ายเลยให้คะแนนในส่วนที่มีการ Reset ค่า หรือรับค่าจากปุ่มแค่ 2 คะแนนจาก 20 คะแนนก็พอ ถ้าทำไม่ได้จะได้ไม่เสียคะแนนมาก

ถึงเวลาของโจทย์ทั้งสี่ข้อแล้วครับ

## Set 1: ACE Counter
### เกริ่น
ข้อนี้ตอนแรกออกไว้ให้เป็นข้อง่ายสุด เพราะมีแค่ 3 States แต่พอออกสามข้อที่เหลือก็รู้สึกว่าง่ายเกินไป เลยปรับเพิ่มโดยให้ต้องมีโหมดที่สองคือตัวอักษรขึ้นทีละตัว จากซ้ายไปขวา ก็เลยกลายเป็นว่า ข้อนี้ไม่ได้ง่ายสุดซะงั้น
### แนวคิด
การแสดงผลตัวเลข A, C, และ E เราสามารถใช้ Module 7-segment ที่เคยใช้ใน Lab 2 ได้เลยครับ โดยโยน Input 10, 12, และ 14 เข้าไป สำหรับกรณีที่มีการสับสวิตซ์ขึ้น แล้วให้แสดงตัวอักษรจากซ้ายไปขวา ให้เราเปลี่ยนวิธีการอัพเดต State ของ `an` สำหรับ 7-segment เป็น `anState = anState - 1` แทน แล้วอาศัยการ Underflow ให้ค่ากลับมาเป็น 3 จาก 0 และใช้ Clock ที่เลือกจากการกดปุ่ม ว่าจะเอา Clock ที่ช่องไหนสำหรับการอัพเดต reg `an` โดยเก็บหมายเลขช่องที่จะใช้ Clock ลงไปใน reg หนึ่งตัว
### จุดที่น่าจะผิด
- ใช้ Operator + ในการเปลี่ยน State ของ an และไม่ได้กำหนดค่า an ให้ถูกต้อง (ยังใช้ `an=4'b1111;an[anState]=0;` เหมือนเดิม) ทำให้ไฟวิ่งจากด้านขวาไปด้านซ้าย
- ประกาศ Bit Width ของ reg สำหรับเลือก Clock ไม่เพียงพอ
- จัดการเรื่อง Overflow ของตัวเลขที่แสดงผลไม่ดี (State ที่จะเปลี่ยน E เป็น A)
- บางทีถ้าเปิด Switch ตัวเดียวอาจมีปัญหาตอน Generate Bitstream เนื่องจาก Constraint File ของบอร์ดนั้น `sw` เป็น Array of wires ดังนั้นจึงอาจเปิด sw เผื่อไปเลย 7 ตัว หรือ 2 ตัว ให้ประกาศ Input ของ System หลักเป็น Array of wires ได้ด้วยเหมือนกัน

## Set 2: Loading Spinner
### เกริ่น
อย่างที่บอกครับ ข้อนี้ง่ายสุด เพราะถึง State ของไฟที่ต้องแสดง จะมีมากถึง 6 States แต่ Action ของการกดปุ่มมีแค่ซ่อนไฟเท่านั้น เท่ากับว่าจะใช้แค่ 2 always Blocks  จึงทำให้มีคนเต็มมากถึง 7 คนในข้อนี้ 
### แนวคิด
ถ้าไม่กดปุ่ม ให้ `an = 0;` เพื่อให้ไฟติดตั้งสี่ดวง แต่ถ้ากดปุ่ม ให้ `an = 4'b1111;` เพื่อดับไฟทั้งหมด ส่วน Spinner ให้เอา Module 7-segment มาแก้ โดยเริ่มจาก `default` ให้มีค่าเป็น `7'b1111110` และไปแก้ของ 1 ให้เป็น `7'b1111101` ทำไปเรื่อย ๆ จนครบ 6 อัน และใน System หลักที่จะโยนตัวเลข `num` เข้า 7-segment Encoder ก็ให้อัพเดต State ของ `num` เป็น `num = (num + 1)%5;` และเนื่องจาก `an` เป็น 0 ทั้ง 4 Bits อยู่แล้ว จอทั้งสี่จอจะแสดงไฟตามค่าของ `seg` ที่ส่งเข้าไปให้บอร์ด
### จุดที่น่าจะผิด
- ไม่น่ามีอะไรผิดนะครับ ยกเว้นทำ State เกิน (คือทำถึง `7'b0111111` ซึ่งจะทำให้มีไฟขึ้นตรงขีดกลางด้วย)

## Set 3: Unary Coding Counter
### เกริ่น
ตอนแรกข้อนี้จะมี 8 แท่งครับ (7-segment 1 ช่องแสดง 3 States คือ ไม่มีไฟ, ขึ้นหนึ่งแท่ง, ขึ้นสองแท่ง) แต่ตอนพี่ลองทำ พี่ใช้เวลา 25 นาที ซึ่งตามหลักคือต้องให้เวลาคนสอบสองเท่า ของเวลาที่คนออกโจทย์คิด + ทำ ก็เลยต้องปรับให้ง่ายลง จึงทำให้ข้อนี้จริง ๆ ถ้ามองออก ก็จะเห็นว่าเขียนเสร็จเร็วกว่า Set 2 อีก
### แนวคิด
เนื่องจากข้อนี้ ขีดที่แสดงต้องขึ้นทางด้านซ้าย แทนด้านขวา (ซึ่งก็คือเลข 1 ที่ได้จาก Module 7-segment) ดังนั้น เราก็ไปแก้ Module 7-segment ของเลข 1 ให้เป็น `7'b1111001` แทน สำหรับ Block ที่ใช้แสดงผล ให้ใช้ `num = 1;` ตลอดเลย และให้มี reg `state` เก็บว่าตอนนี้ต้องแสดงไฟกี่ดวง หลังจากนั้นค่อยใช้ `case` ในการเลือกค่าของ `an` ให้เหมาสม โดยเริ่มจาก `4'b1111`, `4'b0111`, ..., `4'b0000` ส่วนเรื่อง Delay ระหว่างแต่ละ State ที่จะเปลี่ยนไปหลังกดปุ่ม Reset นั้น ให้ทำเหมือนกับ Set 1 แต่ว่าไม่ต้องเปลี่ยน Clock กลับเมื่อกดปุ่มแล้ว
### จุดที่น่าจะผิด
- Set ค่า `state` ใน `always` Block ที่อัพเดต State กับ Block ที่เช็คการกดปุ่ม ซึ่งวิธีที่ถูกต้องคือ `state` ที่ใช้ ควรจะมาจาก `prevState` แต่ถ้าเอาเร็ว ๆ ก็คือรวมการ Set ค่า state ให้เป็น 0 กับ Block ที่ใช้อัพเดตค่า `state` เลยก็ได้ แลกกับการที่อาจจะต้องกด `btnC` ให้นานขึ้น เพื่อให้โดน Positive Edge ของ Clock ที่มีคาบเป็น 1.2 วินาที (ซึ่งตอนตรวจก็ตรวจให้ผ่าน ไม่ว่าจะทำแบบไหนมาก็ตาม)
- ประกาศ Bit Width ไม่พอ (มี 5 States ต้องใช้ `reg [2:0]state`)

## Set 4: Shift Counter
### เกริ่น
ข้อนี้ยากสุดแล้วครับ เพราะสองวิธีที่ทำได้ ถ้าไม่เหนื่อยมาก ๆ ก็จะบัคง่ายมาก แต่ก็มีคนเต็มสองคนนะ ว้าวซ่า
### แนวคิด
วิธีเหนื่อยก็ตรง ๆ เลยครับ เอา Lab 2 มาเติมให้มีครบ 17 States ไล่ตั้งแต่ 1234, 2345, ..., 6789, 8910, 1011, ..., 1920 <br/>
...แต่ถ้าจะไม่เอาเหนื่อย ก็ให้มี reg `num` สำหรับเก็บว่า จะมีตัวเลขอะไรมาต่อ โดยเริ่มจาก 4 และให้มี reg `curNum` ที่เริ่มจาก 123
- หาก `num <= 9` ให้ `curNum = ((curNum*10)+num)%1000;`
- แต่หาก `num <= 20` และ `curNum != 1920` ให้ `curNum = ((curNum*100)+num)%1000;`
โดยตอนจะแสดงผล ให้เอาโค้ด Lab 2 มาเติม โดยให้ `num3 = curNum/1000; num2 = (curNum/100)%10; num1 = (curNum/10)%10; num0 = curNum%10;` ส่วนการ Delay เมื่อกด `btnD` ก็ทำเหมือนกับ Set 1 เลยครับ
### จุดที่น่าจะผิด
- ถ้าทำ Brute-Force มา ก็ต้องเช็คครับว่า State ถูกหมดหรือเปล่า 5 5 5 5
- ถ้าใช้วิธีหลัง แนะนำให้สร้าง `reg [31:0]curNum; reg [15:0]num;` ไปเลยครับ ถูกแน่นอน

## สรุป
ก็ เตรียมทบทวนดี ๆ แล้วเตรียมทำ Project หลังสอบนะครับ โขค
